# 다함께 나누고 묶어보자, 클래스와 객체

### 1.1 객체

* 객체란 __모든 물체를 뜻한다..__ 라고 할 수 있는데, 이건 일반적인 설명이고, C++에서 쓰일법한 말로 다시 설명하면, __프로그램의 행동을 모두 포함한 집합__ 을 뜻합니다.

* 예를 들어, TV의 기능을 객체화 한다면
    * TV끄기/켜기
    * TV볼륨조절
    * TV밝기조절
    * TV체널조절
    * ... 등이 있을 것입니다.
* 자세히 나누면, __상태와 행동 (함수와 변수)__ 로 구성됩니다.

### 1.2 클래스

* 클래스란 __객체를 만들기 위해 정의된 틀__ 입니다. 위에서 객체가 집합이었다면, 이를 __정의__ 시켜주는 것이 클래스입니다.
* 객체의 변수와 함수를 선언합니다.

----

정리하자면, 클래스가 집합을 __정의시킨다면(선언한다면)__, 객체는 이를 사용하여 __실체화(구성)__ 합니다.

----

### 1.3 클래스 만들어서 사용하기

* 클래스는 아래와 같이 만들 수 있습니다.
```cpp
class TV {
public:
    int status_tv_power = 0; // 변수 선언
    int getpowerStatus(); // 함수 선언
};

int TV::getpowerStatus() { // getpowerStatus 함수 구현
    return status_tv_power;
}
```
* 위와 같이 접근 지정자를 사용하며, 함수 구현부분을 클래스 내부에서 만들거나 밖으로 뺄 수 잇습니다.

* 아래와 같이 사용합니다.
```cpp
int main(void) {
    TV tv1; // 불러오기

    tv1.status_tv_power = 1; // 변수 접근
    int getpwstatus = tv1.getpowerStatus(); // 함수 호출
    cout << getpwstatus << endl;
}
```
* 객체 생성시 (클래스 명 객체 이름) 순서로 적습니다.
* 객체 변수 접근시 . 연산자를 활용합니다.

### 1.4 생성자

* 생성자란 객체가 생성될 때 자동으로 호출되는 멤버 함수입니다.
* 클래스 이름과 동일하게 함수 이름을 정합니다.
* 아래와 같이 만들 수 있습니다.
```cpp
class TV {
    TV(); // 아무 내용 없는 함수나
    TV(int a); // 매게 변수가 있는 생성자
};

TV::TV() { // 함수 구현
    ...
}

TV::TV(int a) { // 함수 구현
    ...
}
```
* 아래와 같이 사용합니다.
```cpp
int main(void) {
    TV tv1;
    ...
    TV tv2(SIZE);
    ...
}
```
* 쓰는 이유와 특징은 아래와 같습니다.
    * 객체 생성시 객체가 필요한 초기화를 위해서.
    * 생성자 이름은 클래스 이름과 동일하게 합니다.
    * 생성자는 리턴 타입이 없습니다.
    * 객체 생성시 한번만 호출 가능합니다.
    * 생성자는 중복 가능합니다.
    * 생성자가 없으면 컴파일러가 컴파일시 생성합니다.

* 멤버 변수 초기화 방법은 아래와 같습니다.
    * 생성자 코드에서 초기화
    ```cpp
    var::var() { var1 = 0; var2 = 0; } // 초기화
    ```
    * 생성자 처음에서 초기화
    ```cpp
    var::var() : var1(0), var2(0) { // 초기화
        ...
    }
    ```
    * 클래스 선언부에서 초기화
    ```cpp
    class var {
        int var1 = 0; // 초기화
        int var2 = 0; // 초기화
    public:
        ...
    };
    ```

### 1.5 소멸자

* 소멸자란 객체가 사라질 때 마무리 작업을 위해서 사용합니다. 소멸시점에서 자동으로 호출됩니다.
* 클래스 이름과 동일하게 함수 이름을 정합니다.
* 아래와 같이 만들 수 있습니다.
```cpp
class TV {
    TV(); 
    TV(int a); 
    ...
   ~TV(); // 소멸자 함수 선언
};
...
TV::~TV() { // 소멸자 함수
    ...
}
```
* 아래와 같이 사용합니다.
```cpp
자동생성 됩니다.
```
* 쓰는 이유와 특징은 아래와 같습니다.
    * 객체가 소멸시 마무리 잡업을 위해서.
    * 소멸자 함수는 ~를 붙입니다.
    * 리턴타입이 없고, 어떤것도 리턴하면 안됩니다.
    * 중복이 되지 않습니다
    * 소멸자가 선언이 안되면 컴파일러가 컴파일시 생성합니다.

### 1.6 생성/소멸자 실행 순서

* 전역 객체는 프로그램 실행시 생성되며, 프로그램 종료시 소멸됩니다.
* 지역 객체는 함수 실행시 생성되며, 함수 종료시 소멸됩니다.
* new와 delete는 약간 다르게 적용됩니다.
    * new는 실행시 객체가 생성됩니다.
    * delete 연산자 실행시 객체가 소멸됩니다.

### 1.7 함수 시간 오버헤드 

작은 함수를 실행시키기 위해 선언한다면, 실행하기 위해 부가적인 시간 오버해드가 상대적으로 크다.

* 이를 해결하기 위해서 인라인 함수를 쓴다.
    * 메크로와 유사하다
    * 코드가 확장될 시 사라진다.

### 1.8 C++ 구조체

C++의 구조체는 C와 __동일__ 하다. 더 추가된건 클래스처럼 상속, 멤버, 접근지정자 등이 동일하다. 

* 이제 함수 생성시에 struct 키워드를 생략할 수 있다.
```cpp
struct_name strname;
```

### 1.9 클래스 재사용을 위한 객체화

클래스를 헤더 파일과 cpp파일로 분산화 하여, 어디서든지 클래스를 재사용 할 수 있도록 한다 -> __객체 지향적 설계로 변환한다__

* #include <...> 과 #include "..."의 차이점
    * <...>는 컴파일러의 헤더를 불러오고
    * "..."는 소스 파일이 있는 곳에서 헤더를 불러온다.

### 1.10 객체 포인터

이젠 객체도 포인터화가(...) 된다.

문법 자체는 구조체 포인터를 쓰는 방법과 동일하나, 불러오는 관점에서 약간 더 추가되었다.

* 객체 내부를 불러오는점이 다르다
```cpp
...
int main(void) {
    TV tv1;
    TV *point_tv; // 포인터형 객체 생성

    point_tv = &tv1; // 객체 포인터로 접근

    cout << point_tv->tvOn(); << endl; // tv1의 tvOn()함수 호출
}
```

### 1.11 객체 배열

이젠 또 객체가 배열화도(...) 된다.

문법 자체는 배열과 동일하나, __매게 변수__ 가 있는 생성자를 호출할 수는 없다.
* 배열은 순차적으로 생성되며, 생성된 역순으로 소멸된다.
```cpp
...
int main(void) {
    TV tvs[3]; // 객체 배열 선언

    tvs[0].tvOn(0); // 배열로 접근
    tvs[1].tvOn(1);
    tvs[2].tvOn(0);

    for (int i = 0; i < 3; i++) {
        cout << tvs[i].tvOn << endl; // 배열로 접근
    }

    TV *point_tv;
    point_tv = tvs; // 객체 포인터로 접근

    for (int i = 0; i < 3; i++) {
        cout << point_tv->tvOn() << endl; // 겍체 포인터로 접근
        point_tv++;
    }
}
```

### 1.12 메모리 할당

이전 C언어에서는 메모리 관련 단원이 매우 중요하였다.(일단 포인터 개념부터가 메모리 개념이다) 그래서 C++에 와서도 메모리 관련하여 정/동적 할당이 추가되었다.

* 정적 메모리 할당

기본적인 메모리 할당 방법이다. 변수 선언을 통해서 메모리를 할당받는다.
```cpp
int main(void) {
    int a = 0; // 정적 할당
    int b = 0; // 정적 할당
    ...
}
```

* 동적 메모리 할당

개발자가 개발을 하면서, 적은 양의 메모리나 원하는 경우가 필요하다. 이때 동적으로 메모리 할당을 하게 된다. 이때 이는 실행중인 운영체제로부터 (heap)으로부터 할당을 받게 된다.

C언어에서는 malloc, free등의 함수를 사용하여서 동적으로 메모리 할당을 하였으나, C++에 와서는 **new** 와 **delete** 라는 함수를 사용하게 된다.

* **new**

new 함수는 말 그대로 **메모리를 힙 영역에서 새로 할당해준다.** 객체가 개발자에 의해서 할당 될 경우, 생성자를 호출하게 된다.

* **delete**

delete 함수는 말 그대로 **힙 영역 메모리에 할당된 영역을 제거한다.** 먼저 소멸자를 호출 한 후, 소멸된 객체를 힙에 반환한다.

* new와 delete 를 사용한 예는 아래와 같다.
```cpp
int main(void) {
    int *pInt = new int; // pInt라는 변수에 int 형식의 메모리 동적할당
    Circle *pCircle = new Circle(); // pCircle이라는 변수에 Circle클래스 형식의 메모리 동적할당

    ...

    delete pInt; // 할당 받은 힙 공간 반환
    delete pCircle; // 할당 받은 힙 공간 반환
}
```

### 1.12 나를 알려줘요, this

코딩을 하다 보면, 클래스 공유를 통해서 많은 변수와 인자를 공유할 수 있다. 그렇게 되면, 변수 이름이 겹치는 경우가 빈번하게 생기게 되는데, 그렇게 되면 변수가 겹칠경우 어떤것이 원하는 변수인지 모르는 경우가 발생하게 된다.

이럴때 사용하는것이 나(맴버 함수 내에서의) 를 선언하는것이 this 포인터이다.

* 예를 들어, 아래와 같은 상황에서는 var만 보고서는 어떤 변수가 대입되는지 알 수가 없다.
```cpp
class Classes {
public:
    Classes();
    Classes(int var);
    ...
}

Classes::Classes(int var) {
    var = var; // 이럴 경우 var은 매개 변수인지 맴버 변수인지 알 수가 없다.
}
```

그럴때 this를 사용하게 되면 구분이 쉬워지게 된다.
```cpp
class Classes {
public:
    Classes();
    Classes(int var);
    ...
}

Classes::Classes(int var) {
    this->var = var; // this->var 은 맴버 변수이고, var은 매개 변수 이다.
}
```

* 사용 이유는 아래와 같다.

    * 변수 이름이 겹쳐서 (맴버 변수와 매개 변수의 이름이)
    * 맴버 함수가 자기 자신을 return 하고 싶을 때.

* 마지막으로 사용하면서 지켜야 할 사항은 아래와 같다.

    * 맴버 함수가 아닌 곳에서는 사용이 불가하다 (관련성이 없기 때문에 == 겹치지 않기 때문에)
    * static 맴버 함수가 사용되는곳에선 사용이 불가하다 (객체가 생성되기 전에 static 호출이 있을수도 있기 때문에.)