# 다함께 나누고 묶어보자, 클래스와 객체

### 1.1 객체

* 객체란 __모든 물체를 뜻한다..__ 라고 할 수 있는데, 이건 일반적인 설명이고, C++에서 쓰일법한 말로 다시 설명하면, __프로그램의 행동을 모두 포함한 집합__ 을 뜻합니다.

* 예를 들어, TV의 기능을 객체화 한다면
    * TV끄기/켜기
    * TV볼륨조절
    * TV밝기조절
    * TV체널조절
    * ... 등이 있을 것입니다.
* 자세히 나누면, __상태와 행동 (함수와 변수)__ 로 구성됩니다.

### 1.2 클래스

* 클래스란 __객체를 만들기 위해 정의된 틀__ 입니다. 위에서 객체가 집합이었다면, 이를 __정의__ 시켜주는 것이 클래스입니다.
* 객체의 변수와 함수를 선언합니다.

----

정리하자면, 클래스가 집합을 __정의시킨다면(선언한다면)__, 객체는 이를 사용하여 __실체화(구성)__ 합니다.

----

### 1.3 클래스 만들어서 사용하기

* 클래스는 아래와 같이 만들 수 있습니다.
```cpp
class TV {
public:
    int status_tv_power = 0; // 변수 선언
    int getpowerStatus(); // 함수 선언
};

int TV::getpowerStatus() { // getpowerStatus 함수 구현
    return status_tv_power;
}
```
* 위와 같이 접근 지정자를 사용하며, 함수 구현부분을 클래스 내부에서 만들거나 밖으로 뺄 수 잇습니다.

* 아래와 같이 사용합니다.
```cpp
int main(void) {
    TV tv1; // 불러오기

    tv1.status_tv_power = 1; // 변수 접근
    int getpwstatus = tv1.getpowerStatus(); // 함수 호출
    cout << getpwstatus << endl;
}
```
* 객체 생성시 (클래스 명 객체 이름) 순서로 적습니다.
* 객체 변수 접근시 . 연산자를 활용합니다.

### 1.4 생성자

* 생성자란 객체가 생성될 때 자동으로 호출되는 멤버 함수입니다.
* 클래스 이름과 동일하게 함수 이름을 정합니다.
* 아래와 같이 만들 수 있습니다.
```cpp
class TV {
    TV(); // 아무 내용 없는 함수나
    TV(int a); // 매게 변수가 있는 생성자
};

TV::TV() { // 함수 구현
    ...
}

TV::TV(int a) { // 함수 구현
    ...
}
```
* 아래와 같이 사용합니다.
```cpp
int main(void) {
    TV tv1;
    ...
    TV tv2(SIZE);
    ...
}
```
* 쓰는 이유와 특징은 아래와 같습니다.
    * 객체 생성시 객체가 필요한 초기화를 위해서.
    * 생성자 이름은 클래스 이름과 동일하게 합니다.
    * 생성자는 리턴 타입이 없습니다.
    * 객체 생성시 한번만 호출 가능합니다.
    * 생성자는 중복 가능합니다.
    * 생성자가 없으면 컴파일러가 컴파일시 생성합니다.

* 멤버 변수 초기화 방법은 아래와 같습니다.
    * 생성자 코드에서 초기화
    ```cpp
    var::var() { var1 = 0; var2 = 0; } // 초기화
    ```
    * 생성자 처음에서 초기화
    ```cpp
    var::var() : var1(0), var2(0) { // 초기화
        ...
    }
    ```
    * 클래스 선언부에서 초기화
    ```cpp
    class var {
        int var1 = 0; // 초기화
        int var2 = 0; // 초기화
    public:
        ...
    };
    ```

### 1.5 소멸자

* 소멸자란 객체가 사라질 때 마무리 작업을 위해서 사용합니다. 소멸시점에서 자동으로 호출됩니다.
* 클래스 이름과 동일하게 함수 이름을 정합니다.
* 아래와 같이 만들 수 있습니다.
```cpp
class TV {
    TV(); 
    TV(int a); 
    ...
   ~TV(); // 소멸자 함수 선언
};
...
TV::~TV() { // 소멸자 함수
    ...
}
```
* 아래와 같이 사용합니다.
```cpp
자동생성 됩니다.
```
* 쓰는 이유와 특징은 아래와 같습니다.
    * 객체가 소멸시 마무리 잡업을 위해서.
    * 소멸자 함수는 ~를 붙입니다.
    * 리턴타입이 없고, 어떤것도 리턴하면 안됩니다.
    * 중복이 되지 않습니다
    * 소멸자가 선언이 안되면 컴파일러가 컴파일시 생성합니다.

### 1.6 생성/소멸자 실행 순서

* 전역 객체는 프로그램 실행시 생성되며, 프로그램 종료시 소멸됩니다.
* 지역 객체는 함수 실행시 생성되며, 함수 종료시 소멸됩니다.
* new와 delete는 약간 다르게 적용됩니다.
    * new는 실행시 객체가 생성됩니다.
    * delete 연산자 실행시 객체가 소멸됩니다.

### 1.7 함수 시간 오버헤드 

작은 함수를 실행시키기 위해 선언한다면, 실행하기 위해 부가적인 시간 오버해드가 상대적으로 크다.

* 이를 해결하기 위해서 인라인 함수를 쓴다.
    * 메크로와 유사하다
    * 코드가 확장될 시 사라진다.

### 1.8 C++ 구조체

C++의 구조체는 C와 __동일__ 하다. 더 추가된건 클래스처럼 상속, 멤버, 접근지정자 등이 동일하다. 

* 이제 함수 생성시에 struct 키워드를 생략할 수 있다.
```cpp
struct_name strname;
```

### 1.9 클래스 재사용을 위한 객체화

클래스를 헤더 파일과 cpp파일로 분산화 하여, 어디서든지 클래스를 재사용 할 수 있도록 한다 -> __객체 지향적 설계로 변환한다__

* #include <...> 과 #include "..."의 차이점
    * <...>는 컴파일러의 헤더를 불러오고
    * "..."는 소스 파일이 있는 곳에서 헤더를 불러온다.

### 1.10 객체 포인터

이젠 객체도 포인터화가(...) 된다.

문법 자체는 구조체 포인터를 쓰는 방법과 동일하나, 불러오는 관점에서 약간 더 추가되었다.

* 객체 내부를 불러오는점이 다르다
```cpp
...
int main(void) {
    TV tv1;
    TV *point_tv; // 포인터형 객체 생성

    point_tv = &tv1; // 객체 포인터로 접근

    cout << point_tv->tvOn(); << endl; // tv1의 tvOn()함수 호출
}
```

### 1.11 객체 배열

이젠 또 객체가 배열화도(...) 된다.

문법 자체는 배열과 동일하나, __매게 변수__ 가 있는 생성자를 호출할 수는 없다.
* 배열은 순차적으로 생성되며, 생성된 역순으로 소멸된다.
```cpp
...
int main(void) {
    TV tvs[3]; // 객체 배열 선언

    tvs[0].tvOn(0); // 배열로 접근
    tvs[1].tvOn(1);
    tvs[2].tvOn(0);

    for (int i = 0; i < 3; i++) {
        cout << tvs[i].tvOn << endl; // 배열로 접근
    }

    TV *point_tv;
    point_tv = tvs; // 객체 포인터로 접근

    for (int i = 0; i < 3; i++) {
        cout << point_tv->tvOn() << endl; // 겍체 포인터로 접근
        point_tv++;
    }
}
```

### 1.12 메모리 할당

이전 C언어에서는 메모리 관련 단원이 매우 중요하였다.(일단 포인터 개념부터가 메모리 개념이다) 그래서 C++에 와서도 메모리 관련하여 정/동적 할당이 추가되었다.

* 정적 메모리 할당

기본적인 메모리 할당 방법이다. 변수 선언을 통해서 메모리를 할당받는다.
```cpp
int main(void) {
    int a = 0; // 정적 할당
    int b = 0; // 정적 할당
    ...
}
```

* 동적 메모리 할당
