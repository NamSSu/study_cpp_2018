# Call by ~~? 객체 심화

### 1.1 Call By 개념

이전 C언어 시간에 변수와 포인터에 대한 대략적인 개념을 배웠을 것이다. 그 당시 변수는 "값"을 받고, 포인터는 "주소"를 받는다는 것을 배웠다.

그럼 받았으면 전달도 할 수 있어야 하는데, 이것이 바로 "Call By ~" 개념이다.

2가지 호출 방법이 있는데, **값에 의한 호출(Call By Value)** 와 **주소에 의한 호출(Call By Address)** 이다.

* **값에 의한 호출(Call By Value)**

아래의 예제 코드를 보자.
```cpp
void swap(int a, int b) {
    int tmp;

    tmp = a;
    a = b; // 값을 전달받아서 처리한다.
    b = tmp;
}
int main(void) {
    int a = 1, b = 2;
    swap(a, b); // 직접 값을 전달한다.
    cout << m << ' ' << n << endl;
}
```

예제 코드를 보면, 값을 swap함수에 직접 전달하여서 처리를 하는 모습을 볼 수 있고, 함수를 호출하는 쪽에서 겍체를 전달한다. 또한 생성시에 생성자는 호출되지 않고, 종료시에 소멸자가 호출된다.

결론은, **직접 값을 전달하여 처리를 하는 방법** 이 값에 의한 호출이다.

* **주소에 의한 호출(Call By Address)**

아래의 예제 코드를 보자.
```cpp
void swap(int *a, int *b) {
    int tmp;

    tmp = *a;
    *a = *b; // 주소를 전달 받아서 처리한다.
    *b = tmp;
}
int main(void) {
    int a = 1, b = 2;
    swap(&a, &b); // 직접 주소를 전달한다.
    cout << m << ' ' << n << endl;
}
```

예제 코드를 보면, 주소를 swap 함수에 직접 전달하여서 처리르 하는 모습을 볼 수 있다.

결론은, **직접 주소를 전달하여 처리를 하는 방법** 이 주소에 의한 호출이다.

### 1.2 참조 변수

C언어 시간에서, scanf 를 통해서 사용자 입력을 받을 때, 받을 변수 인자에 & 를 붙여주었다. 이는 **참조**라고 했었다.

C++ 에서는 그 개념이 더욱 확장되어서 **이미 존재하는 변수에 대해서 다른이름(별명)을 선언 가능하다.**

아래의 예제 코드를 보자.
```cpp
int main(void) {
    int var = 2;
    &ref_var = var; // ref_var 라는 참조 변수 선언

    ref_var = 3; // ref_var == var 이므로 var 의 값은 3으로 변경
    cout << ref_var << endl; // 3 출력
}
```

예제 코드를 보면, ref_var 이라는 참조 변수를 var에 대해서 선언함으로써, ref_var로 접근하여 var 값을 수정 할 수 있다.

### 1.3 Call By 개념 2, Call By Reference

코딩을 하다 보면, 어디선가 "Call By Reference" 라는 개념을 많이 들어 보았을 것이다. 

이는 **"참조에 의한 호출"** 로써, 1.2 에서 말했던 **참조 변수를 호출**하는 행위를 말한다.

아래와 같은 특징이 있다.
* 참조 변수의 이름만 생기고 공간이 생기지 않는다.
* 참조 변수는 실 변수 공간을 공유한다.
* 참조 변수의 조작은 실 변수 공간을 조작한다.

아래의 예제 코드를 보자.
```cpp
void swap(int &a, int &b) { // 참조 매개 변수
    int tmp;

    tmp = a;
    a = b; // 참조 변수를 보통 변수처럼 처리한다.
    b = tmp;
}
int main(void) {
    int a = 1, b = 2;
    swap(a, b);
    cout << m << ' ' << n << endl;
}
```

예제 코드를 보면, int &a, int &b 로 참조 매개 변수를 받는 것을 알 수 있다. 이럴 경우, main함수 내에 있는 a와 b의 값이 직접 바뀌게 된다.

마지막으로, 호출이 가능하면 값을 return하는 행위도 가능하다. 이 부분은 C와 C++ 가 약간씩 다르다.

* C
    * 모든 함수는 **값**을 리턴해야한다.
* C++
    * 값 이외에도 참조를 리턴 가능하다.
    * 참조를 리턴시에는 **현존하는 공간** 을 리턴한다. (변수의 값을 리턴하는것이 아니다.)

### 1.4 복사도 서로 달라요, 얕은 복사와 깊은 복사.

* **앝은 복사**
    * 객체 복사 시, 객체의 맴버를 1:1로 복사하는 것을 말한다.
    * 사본은 원본 메모리와 공유하기 때문에, 메모리 공유 문제가 발생한다.
* **깊은 복사**
    * 객체 복사 시, 객체의 맴버를 완벽하게 1:1 로 복제하는 것을 말한다. (복사와 복제의 차이)
    * 완벽한 복제이기 때문에 메모리 문제는 없다.
* **복사 생성자 (Copy constructor)**
    * 객체의 복사 생성시 호출되는 생성자
    * 한 클래스 내에 오직 한 개만 호출 가능하다.

아래의 예제 코드를 보자.
```cpp
class Classes {
public:
    Classes();
    Classes(Classes& c); // 복사 생성자 선언
    ...
}
Classes::Classes(Classes& c) { // 복사 생성자 구현
    ...
}

```

Classes(Classes& c); 와 같은 형태로 선언하고 사용이 가능하다.